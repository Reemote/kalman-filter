<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Kalman Filter Demo on Bike Image</title>
<style>
    .img{
        position: relative;
        display: inline-block; /* Make the width of box same as image */
    }
    .img .box{
        position: absolute;
        z-index: 999;
        margin: 0 auto;
    }

		.top-right {
			position: absolute;
			top: 20px;
	    right: 20px;
	    background-color: grey;
	    color: white;
	    padding-left: 20px;
	    padding-right: 20px;
		}
		.img .boxPlainRed{
        position: absolute;
        z-index: 999;
        margin: 0 auto;
				border: 2px solid red;
				background-color: red;
    }
		.img .boxPlainBlue{
				position: absolute;
				z-index: 999;
				margin: 0 auto;
				border: 2px solid blue;
				background-color: blue;
		}
		.img .ellipse {
			position: absolute;
			z-index: 999;
			margin: 0 auto;
			border: 1px dotted blue;
			border-radius: 50%;
		}
		.arrow {
		  position: absolute;
		  color: black;
		  border-width: 6px;
		  border-style: solid;
		  border-bottom-color: transparent;
		  border-left-color: transparent;
		  position: relative;
		  display: inline-block;
		  vertical-align: middle;
		  color: #666;
		  box-sizing: border-box;
		}

		.arrow:before{
		    right: 0;
		    top: -3px;
		    position: absolute;
		    height: 4px;
		    box-shadow: inset 0 0 0 32px;
		    transform: rotate(-45deg);
		    width: 15px;
		    transform-origin: right top;
		    content: "";
		    box-sizing: border-box;
		}


</style>


</head>
<body>
    <div class="img" id='bikes'>
        <img src="https://www.simply.science/images/content/physics/mechanics/kinematics/Concept_map/image1.gif">
				<div class="top-right">
					<h4 style="color: red;"> Prediction
					</h4>
					<h4 style="color: white;"> Observation
					</h4>
					<h4 style="color: blue;"> Correction
					</h4>
				</div>
				<div class="arrow">
				</div>
    </div>
</body>
<script src="kalman-filter.js">
</script>
<script>
	var KalmanFilter = require('KalmanFilter');
	const timeStep = 0.2;
	const huge = 1;
	const posVar = 100;
	const sizeVar = 1;
	const defaultOptions = {
		observation: {
			dimension: 4,
			stateProjection: [
					[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
					[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
					[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
					[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]
				],
			covariance: [20, 20, 20, 20],
		},

		dynamic: {
			name: 'constant-acceleration',
			timeStep: 0.2,
			init: {
				mean: [[943], [385], [75], [65], [-200], [-200], [0], [0], [-20], [-20], [0], [0]],

				covariance: [
					[huge, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
					[0, huge, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
					[0, 0, huge, 0, 0, 0, 0, 0, 0, 0, 0, 0],
					[0, 0, 0, huge, 0, 0, 0, 0, 0, 0, 0, 0],
					[0, 0, 0, 0, huge, 0, 0, 0, 0, 0, 0, 0],
					[0, 0, 0, 0, 0, huge, 0, 0, 0, 0, 0, 0],
					[0, 0, 0, 0, 0, 0, huge, 0, 0, 0, 0, 0],
					[0, 0, 0, 0, 0, 0, 0, huge, 0, 0, 0, 0],
					[0, 0, 0, 0, 0, 0, 0, 0, huge, 0, 0, 0],
					[0, 0, 0, 0, 0, 0, 0, 0, 0, huge, 0, 0],
					[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, huge, 0],
					[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, huge],
				]
			},

			dimension: 12,

			covariance: [
				posVar, posVar, sizeVar, sizeVar,
				posVar*timeStep*timeStep, posVar*timeStep*timeStep, sizeVar*timeStep*timeStep, sizeVar*timeStep*timeStep,
				posVar*timeStep**4, posVar*timeStep**4, sizeVar*timeStep**4, sizeVar*timeStep**4
			]
		}
	};

	const kf = new KalmanFilter(defaultOptions);
	let previousCorrected;
	let predicted = kf.predict();
	const img = document.getElementById('bikes')
	const boxes = [
		[
			849, 294, 86, 83
		],
		[
			705, 186, 101, 86
		],
		[
			564, 108, 108, 109
		],
		[
			427, 100, 87, 101
		],
		[
			285, 132, 84, 89
		],
		[
			152, 195, 84, 77
		],
		[
			21, 302, 83, 83
		]
	];
	const delay = 1000;
	let promise = Promise.resolve();

	const createElement = function({className, tag = 'div', bbox, parent, color, lineStyle, rotationCoefficient}) {
		const el = document.createElement(tag);
		el.className = className;
		if (color && lineStyle) {
			el.style.border = `1px ${lineStyle} ${color}`
		}
		el.style.width= Math.round(bbox[2])+ 'px';
		el.style.height= Math.round(bbox[3]) + 'px';
		el.style.top= Math.round(bbox[1] -bbox[3]/2) + 'px';
		el.style.left= Math.round(bbox[0] - bbox[2]/2) + 'px';
		if (rotationCoefficient) {
			el.style.transform = `rotate(${rotationCoefficient}deg)`
		}
		parent.append(el);
		return el;
	}

	const createArrow = function({className, tag = 'div', bbox, parent, rotationCoefficient}) {
		const el = document.createElement(tag);
		el.className = className;
		el.style.top= Math.round(bbox[1] -bbox[3]/2) + 'px';
		el.style.left= Math.round(bbox[0] - bbox[2]/2) + 'px';
		if (rotationCoefficient) {
			el.style.transform = `rotate(${rotationCoefficient}deg)`
		}
		parent.append(el);
		return el;
	}

	boxes.forEach((box, index) => {
		promise = promise.then(function(b, index){
			console.log("Predicted", predicted)
			const {mean, covariance} = predicted;
			const center = [mean[0][0] + mean[2][0]/2, mean[1][0] + mean[3][0]/2];

			const el = createElement({
				className: 'box',
				bbox: [center[0], center[1], mean[2][0], mean[3][0]],
				parent: img,
				color: 'red',
				lineStyle: 'solid',
			})
			const el2 = createElement({
				className: 'box',
				bbox: [
					center[0],
					center[1],
					mean[2][0] + 2*3*Math.sqrt(covariance[2][2]),
					mean[3][0] +2*3*Math.sqrt(covariance[3][3])
				],
				parent: img,
				color: 'red',
				lineStyle: 'dotted'
			});
			const el3 = createElement({
				className: 'boxPlainRed',
				bbox: [center[0], center[1], 2, 2],
				parent: img
			})
			return new Promise((resolve, reject) => {
				setTimeout(() => {
					resolve()
				}, delay);
			})
		}.bind(null, box, index))
		.then(function(b, index){
			const el = createElement({
				className: 'box',
				bbox: [
					b[0] +b[2]/2,
					b[1] +b[3]/2,
					b[2],
					b[3]
				],
				parent: img,
				color: 'white',
				lineStyle: 'solid'
			})

			return new Promise((resolve, reject) => {
				setTimeout(() => {
					resolve()
				}, delay);
			})
		}.bind(null, box, index))
		.then(function(b, index){
			previousCorrected = kf.correct({predicted, observation: b});
			console.log("box", b);
			console.log("Corrected", previousCorrected)
			const {mean, covariance} = previousCorrected
			const center = [mean[0][0] + mean[2][0]/2, mean[1][0] + mean[3][0]/2];
			const el1 = createElement({
				className: 'box',
				bbox:[
					center[0],
					center[1],
					mean[2][0],
					mean[3][0]
				],
				parent: img,
				color: 'blue',
				lineStyle:'solid'
			});

			const el2 = createElement({
				className: 'box',
				bbox: [
					center[0],
					center[1],
					mean[2][0] + 2*3*Math.sqrt(covariance[2][2]),
					mean[3][0] +2*3*Math.sqrt(covariance[3][3])
				],
				parent: img,
				color: 'blue',
				lineStyle: 'dotted'
			});

			const el3 = createElement({
				className: 'boxPlainBlue',
				bbox: [
					center[0]-1,
					center[1]-1,
					2,
					2
				],
				parent: img
			})
			const correlationXY = covariance[0][1]/(Math.sqrt(covariance[0][0])*Math.sqrt(covariance[1][1]))
			const el4 = createArrow({
				className: 'arrow',
				bbox: [
					center[0],
					center[1]
				],
				parent: img,
				rotationCoefficient: 45
			})
			predicted = kf.predict({previousCorrected})
		return new Promise((resolve, reject) => {
			setTimeout(() => {
				resolve()
			}, delay);
		})
	}.bind(null, box, index))
	})



</script>

</html>
