<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Kalman Filter Demo on Bike Image</title>
<style>
    .img{
        position: relative;
        display: inline-block; /* Make the width of box same as image */
    }
    .img .box{
        position: absolute;
        z-index: 999;
        margin: 0 auto;
				border: 1px solid white;
    }

		.top-right {
			position: absolute;
			top: 20px;
	    right: 20px;
	    background-color: grey;
	    color: white;
	    padding-left: 20px;
	    padding-right: 20px;
		}
		.img .point{
        position: absolute;
        z-index: 999;
        margin: 0 auto;
				border: 2px solid red;

    }
		.img .ellipse {
			position: absolute;
			z-index: 999;
			margin: 0 auto;
			border-radius: 50%;
		}
		.arrow {
		  position: absolute;
		  color: black;
		  border-width: 4px;
		  border-style: solid;
		  border-bottom-color: transparent;
		  border-left-color: transparent;
		  display: inline-block;
		  vertical-align: middle;
		  box-sizing: border-box;
		}

		.arrow:before{
		    right: 0;
		    top: -3px;
		    position: absolute;
		    height: 3px;
		    box-shadow: inset 0 0 0 32px;
		    transform: rotate(-45deg);
		    width: 15px;
		    transform-origin: right top;
		    content: "";
		    box-sizing: border-box;
		}
		div.img .stdDev{
			border-style: dotted;
		}
		.img .predicted .box,.img .predicted .ellipse, .img .predicted .point{
			border-color: red;
		}
		.img .corrected .box,.img .corrected .ellipse, .img .corrected .point{
			border-color: blue;
		}


</style>


</head>
<body>
    <div class="img" id='bikes'>
        <img src="https://www.simply.science/images/content/physics/mechanics/kinematics/Concept_map/image1.gif">
				<div class="top-right">
					<h4 style="color: red;"> Prediction
					</h4>
					<h4 style="color: white;"> Observation
					</h4>
					<h4 style="color: blue;"> Correction
					</h4>
				</div>
				<div class="arrow">
				</div>
    </div>
</body>
<script src="kalman-filter.js">
</script>
<script>
	var KalmanFilter = require('KalmanFilter');
	var generateNoisyObservation = require('generateNoisyObservation');
	var calculateObservationCovariance = require ('calculateObservationCovariance');
	//var url = require('url');
	const timeStep = 0.2;
	const huge = 1;
	const posVar = 100;
	const sizeVar = 1;
	const boxes = [
		[
			849, 294, 86, 83
		],
		[
			705, 186, 101, 86
		],
		[
			564, 108, 108, 109
		],
		[
			427, 100, 87, 101
		],
		[
			285, 132, 84, 89
		],
		[
			152, 195, 84, 77
		],
		[
			21, 302, 83, 83
		]
	];
	console.log(calculateObservationCovariance({groundTruths: boxes}));
	const noisyObservations = generateNoisyObservation({groundTruths: boxes})[0];
	const observationCovariance = [[35,26.857142857142858,3,24.428571428571427],[26.857142857142858,34.57142857142857,-0.2857142857142857,17.857142857142858],[3,-0.2857142857142857,33,-6.571428571428571],[24.428571428571427,17.857142857142858,-6.571428571428571,41.142857142857146]]
	console.log(observationCovariance);
	const defaultOptions = {
		observation: {
			dimension: 4,
			stateProjection: [
					[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
					[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
					[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
					[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]
				],
			//Covariance generated thanks to getCovariance
			covariance: observationCovariance
			//covariance: [posVar, posVar, posVar, posVar],

		},

		dynamic: {
			name: 'constant-acceleration',
			timeStep: 0.2,
			// init: {
			// 	mean: [[943], [385], [75], [65], [-200], [-200], [0], [0], [-20], [-20], [0], [0]],
			//
			// 	covariance: [
			// 		[huge, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			// 		[0, huge, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			// 		[0, 0, huge, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			// 		[0, 0, 0, huge, 0, 0, 0, 0, 0, 0, 0, 0],
			// 		[0, 0, 0, 0, huge, 0, 0, 0, 0, 0, 0, 0],
			// 		[0, 0, 0, 0, 0, huge, 0, 0, 0, 0, 0, 0],
			// 		[0, 0, 0, 0, 0, 0, huge, 0, 0, 0, 0, 0],
			// 		[0, 0, 0, 0, 0, 0, 0, huge, 0, 0, 0, 0],
			// 		[0, 0, 0, 0, 0, 0, 0, 0, huge, 0, 0, 0],
			// 		[0, 0, 0, 0, 0, 0, 0, 0, 0, huge, 0, 0],
			// 		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, huge, 0],
			// 		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, huge],
			// 	]
			// },

			dimension: 12,

			covariance: [
				posVar, posVar, sizeVar, sizeVar,
				posVar*timeStep*timeStep, posVar*timeStep*timeStep, sizeVar*timeStep*timeStep, sizeVar*timeStep*timeStep,
				posVar*timeStep**4, posVar*timeStep**4, sizeVar*timeStep**4, sizeVar*timeStep**4
			]
		}
	};

	const kf = new KalmanFilter(defaultOptions);
	let previousCorrected;
	let predicted = kf.predict();
	const img = document.getElementById('bikes')

	const delay = 1000;
	let promise = Promise.resolve();

	const createElement = function({className, tag = 'div', bbox, parent, color, lineStyle, rotationCoefficient}) {
		const el = document.createElement(tag);
		el.className = className;
		// if (color && lineStyle) {
		// 	el.style.border = `1px ${lineStyle} ${color}`
		// }
		el.style.width= Math.round(bbox[2])+ 'px';
		el.style.height= Math.round(bbox[3]) + 'px';
		el.style.top= Math.round(bbox[1] -bbox[3]/2) + 'px';
		el.style.left= Math.round(bbox[0] - bbox[2]/2) + 'px';
		if (rotationCoefficient) {
			el.style.transform = `rotate(${rotationCoefficient}deg)`
		}
		parent.append(el);
		return el;
	}
	const createPoint = function({className = 'point', tag = 'div', bbox, parent, color}) {
		const el = document.createElement(tag);
		el.className = className;
		// if (color) {
		// 	el.style.border = `2px solid ${color}`,
		// 	el.style.backgroundColor = `${color}`
		// }
		el.style.width= Math.round(bbox[2])+ 'px';
		el.style.height= Math.round(bbox[3]) + 'px';
		el.style.top= Math.round(bbox[1] -bbox[3]/2) + 'px';
		el.style.left= Math.round(bbox[0] - bbox[2]/2) + 'px';
		parent.append(el);
		return el;
	}

	const createArrow = function({className, tag = 'div', bbox, parent, rotationCoefficient, length}) {
		const el = document.createElement(tag);
		el.className = className;
		el.style.top= Math.round(bbox[1]) + 'px';
		el.style.left= Math.round(bbox[0]) + 'px';
		if (rotationCoefficient) {
			el.style.transform = `rotate(${rotationCoefficient}deg)`
			el.style.transformOrigin = "-5px 12px"
		}
		el.style.height = length
		parent.append(el);
		return el;
	}

	const createCustomDashedLine = function({className, tag = 'div', bbox, parent, color, percentage, position = 'vertical'}) {
		// bbox contains 3 elements: left, top and bottom of the dashed line or top, left and right
		const el = document.createElement(tag);
		// if (color) {
		// 	el.style.backgroundColor = color
		// }
		el.className = className;
		if (position === 'vertical') {
			el.style.width = 1 +'px';
			el.style.height= Math.abs(bbox[1] - bbox[2]) + 'px';
			el.style.top= bbox[1] + 'px';
			el.style.left = bbox[0] + 'px'
		}
		if (position === 'horizontal') {
			el.style.height = 1 +'px';
			el.style.width= Math.abs(bbox[1] - bbox[2]) + 'px';
			el.style.left= bbox[1] + 'px';
			el.style.top = bbox[0] + 'px'
		}

		//el.style.opacity = 1-percentage
		const urlString = `data:image/svg+xml,%3csvg `+
			`width='100%25' `+
			`height='100%25' `+
			`xmlns='http://www.w3.org/2000/svg'%3e%3crect `+
			`width='100%25' `+
			`height='100%25' `+
			`fill='none' `+
			`stroke='black' `+
			`stroke-width='4' `+
			`stroke-dasharray='10%2c${Math.floor(percentage*100)}' `+
			`stroke-dashoffset='0' `+
			`stroke-linecap='round'/%3e%3c/svg%3e`;

		const backgroundImage1 = `url("${urlString}")`;

		// const backgroundImage2 = "url(\"data:image/svg+xml,%3csvg width='100%25' height='100%25' xmlns='http://www.w3.org/2000/svg'%3e%3crect width='100%25' height='100%25' fill='none' stroke='%23333' stroke-width='4' stroke-dasharray='10%2c20' stroke-dashoffset='0' stroke-linecap='square'/%3e%3c/svg%3e\")"
		// console.log(backgroundImage1, backgroundImage2, backgroundImage1===backgroundImage2)
		el.style.backgroundImage = backgroundImage1 ;
		parent.append(el);
		return el;
	}

	const createGroupBoxes = function({mean, covariance, color, parent, className}) {
		const container = document.createElement('div');
		container.className = className;
		const center = [mean[0][0] + mean[2][0]/2, mean[1][0] + mean[3][0]/2];
		const el = createElement({
			className: 'box',
			bbox: [center[0], center[1], mean[2][0], mean[3][0]],
			parent: container,
			color,
			lineStyle: 'solid',
		})
		const el2 = createElement({
			className: 'box stdDev',
			bbox: [
				center[0],
				center[1],
				mean[2][0] + 2*3*Math.sqrt(covariance[2][2]),
				mean[3][0] +2*3*Math.sqrt(covariance[3][3])
			],
			parent: container,
			color,
		});
		const el3 = createPoint({
			bbox: [center[0], center[1], 2, 2],
			parent: container,
			color
		});
		const correlationXY = covariance[0][1]/(Math.sqrt(covariance[0][0])*Math.sqrt(covariance[1][1]))
		const el4 = createElement({
			className: 'ellipse stdDev',
			bbox: [
				center[0],
				center[1],
				2*3*Math.sqrt(covariance[0][0]),
				2*3*Math.sqrt(covariance[1][1])
			],
			parent: container,
			rotationCoefficient: correlationXY,
			color
		});
		parent.appendChild(container);
		return container;
	}

	noisyObservations.forEach((box, index) => {
		promise = promise.then(function(b, index){
			console.log("Predicted", predicted)
			const {mean, covariance} = predicted;
			const center = [mean[0][0] + mean[2][0]/2, mean[1][0] + mean[3][0]/2];

			const predictedGroupBoxes = createGroupBoxes({mean, covariance, parent: img, className: "predicted"})


			return new Promise((resolve, reject) => {
				setTimeout(() => {
					resolve()
				}, delay);
			})
		}.bind(null, box, index))
		.then(function(b, index){
			const el = createElement({
				className: 'box',
				bbox: [
					b[0] +b[2]/2,
					b[1] +b[3]/2,
					b[2],
					b[3]
				],
				parent: img,
				color: 'white',
				lineStyle: 'solid'
			})

			return new Promise((resolve, reject) => {
				setTimeout(() => {
					resolve()
				}, delay);
			})
		}.bind(null, box, index))
		.then(function(b, index){
			previousCorrected = kf.correct({predicted, observation: b});
			console.log("box", b);
			console.log("Corrected", previousCorrected)
			const {mean, covariance} = previousCorrected

			const correctedGroupBoxes = createGroupBoxes({mean, covariance, parent: img, className: "corrected"})
			const center = [mean[0][0] + mean[2][0]/2, mean[1][0] + mean[3][0]/2];

			const arrowRotation = -Math.atan(mean[4][0]/mean[5][0])*180/Math.PI -45;
			const arrowLength = Math.sqrt(mean[4][0]**2 + mean[5][0]**2);
			const el5 = createArrow({
				className: 'arrow',
				bbox: [
					center[0]+6,
					center[1] -9
				],
				parent: img,
				rotationCoefficient: arrowRotation,
				length: arrowLength
			})
			const correlationXW = covariance[0][2]/(Math.sqrt(covariance[0][0])*Math.sqrt(covariance[2][2]));
			const dashedLineXW = createCustomDashedLine({
				className: 'box',
				bbox: [
					center[0],
					center[1] +3*Math.sqrt(covariance[1][1]),
					center[1] + mean[3][0]/2 +3*Math.sqrt(covariance[3][3]),
				],
				parent: img,
				percentage: Math.abs(correlationXW),
				color: 'black'
			});
			const correlationYH = covariance[1][3]/(Math.sqrt(covariance[1][1])*Math.sqrt(covariance[3][3]));
			const dashedLineYH = createCustomDashedLine({
				className: 'box',
				bbox: [
					center[1],
					center[0] +3*Math.sqrt(covariance[0][0]),
					center[0] + mean[2][0]/2 +3*Math.sqrt(covariance[2][2]),
				],
				parent: img,
				percentage: Math.abs(correlationYH),
				color: 'black',
				position: 'horizontal'
			})
			predicted = kf.predict({previousCorrected})
		return new Promise((resolve, reject) => {
			setTimeout(() => {
				resolve()
			}, delay);
		})
	}.bind(null, box, index))
	})



</script>

</html>
