<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Kalman Filter Demo on Bike Image</title>
<style>
    .img{
        position: relative;
        display: inline-block; /* Make the width of box same as image */
    }
    .img .box{
        position: absolute;
        z-index: 999;
        margin: 0 auto;
    }

		.top-right {
			position: absolute;
			top: 20px;
	    right: 20px;
	    background-color: grey;
	    color: white;
	    padding-left: 20px;
	    padding-right: 20px;
		}
		.img .point{
        position: absolute;
        z-index: 999;
        margin: 0 auto;
				border: 2px solid red;
				background-color: red;
    }
		.img .ellipse {
			position: absolute;
			z-index: 999;
			margin: 0 auto;
			border-radius: 50%;
		}
		.arrow {
		  position: absolute;
		  color: black;
		  border-width: 4px;
		  border-style: solid;
		  border-bottom-color: transparent;
		  border-left-color: transparent;
		  display: inline-block;
		  vertical-align: middle;
		  box-sizing: border-box;
		}

		.arrow:before{
		    right: 0;
		    top: -3px;
		    position: absolute;
		    height: 3px;
		    box-shadow: inset 0 0 0 32px;
		    transform: rotate(-45deg);
		    width: 15px;
		    transform-origin: right top;
		    content: "";
		    box-sizing: border-box;
		}


</style>


</head>
<body>
    <div class="img" id='bikes'>
        <img src="https://www.simply.science/images/content/physics/mechanics/kinematics/Concept_map/image1.gif">
				<div class="top-right">
					<h4 style="color: red;"> Prediction
					</h4>
					<h4 style="color: white;"> Observation
					</h4>
					<h4 style="color: blue;"> Correction
					</h4>
				</div>
				<div class="arrow">
				</div>
    </div>
</body>
<script src="kalman-filter.js">
</script>
<script>
	var KalmanFilter = require('KalmanFilter');
	var generateNoisyObservation = require('generateNoisyObservation');
	var calculateObservationCovariance = require ('calculateObservationCovariance');
	const timeStep = 0.2;
	const huge = 1;
	const posVar = 100;
	const sizeVar = 1;
	const boxes = [
		[
			849, 294, 86, 83
		],
		[
			705, 186, 101, 86
		],
		[
			564, 108, 108, 109
		],
		[
			427, 100, 87, 101
		],
		[
			285, 132, 84, 89
		],
		[
			152, 195, 84, 77
		],
		[
			21, 302, 83, 83
		]
	];
	console.log(calculateObservationCovariance({groundTruths: boxes}));
	const noisyObservations = generateNoisyObservation({groundTruths: boxes})[0];
	const defaultOptions = {
		observation: {
			dimension: 4,
			stateProjection: [
					[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
					[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
					[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
					[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]
				],
			//Covariance generated thanks to getCovariance
			covariance: calculateObservationCovariance({groundTruths: boxes})[0]
			//covariance: [posVar, posVar, posVar, posVar],

		},

		dynamic: {
			name: 'constant-acceleration',
			timeStep: 0.2,
			// init: {
			// 	mean: [[943], [385], [75], [65], [-200], [-200], [0], [0], [-20], [-20], [0], [0]],
			//
			// 	covariance: [
			// 		[huge, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			// 		[0, huge, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			// 		[0, 0, huge, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			// 		[0, 0, 0, huge, 0, 0, 0, 0, 0, 0, 0, 0],
			// 		[0, 0, 0, 0, huge, 0, 0, 0, 0, 0, 0, 0],
			// 		[0, 0, 0, 0, 0, huge, 0, 0, 0, 0, 0, 0],
			// 		[0, 0, 0, 0, 0, 0, huge, 0, 0, 0, 0, 0],
			// 		[0, 0, 0, 0, 0, 0, 0, huge, 0, 0, 0, 0],
			// 		[0, 0, 0, 0, 0, 0, 0, 0, huge, 0, 0, 0],
			// 		[0, 0, 0, 0, 0, 0, 0, 0, 0, huge, 0, 0],
			// 		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, huge, 0],
			// 		[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, huge],
			// 	]
			// },

			dimension: 12,

			covariance: [
				posVar, posVar, sizeVar, sizeVar,
				posVar*timeStep*timeStep, posVar*timeStep*timeStep, sizeVar*timeStep*timeStep, sizeVar*timeStep*timeStep,
				posVar*timeStep**4, posVar*timeStep**4, sizeVar*timeStep**4, sizeVar*timeStep**4
			]
		}
	};

	const kf = new KalmanFilter(defaultOptions);
	let previousCorrected;
	let predicted = kf.predict();
	const img = document.getElementById('bikes')

	const delay = 1000;
	let promise = Promise.resolve();

	const createElement = function({className, tag = 'div', bbox, parent, color, lineStyle, rotationCoefficient}) {
		const el = document.createElement(tag);
		el.className = className;
		if (color && lineStyle) {
			el.style.border = `1px ${lineStyle} ${color}`
		}
		el.style.width= Math.round(bbox[2])+ 'px';
		el.style.height= Math.round(bbox[3]) + 'px';
		el.style.top= Math.round(bbox[1] -bbox[3]/2) + 'px';
		el.style.left= Math.round(bbox[0] - bbox[2]/2) + 'px';
		if (rotationCoefficient) {
			el.style.transform = `rotate(${rotationCoefficient}deg)`
		}
		parent.append(el);
		return el;
	}
	const createPoint = function({className = 'point', tag = 'div', bbox, parent, color}) {
		const el = document.createElement(tag);
		el.className = className;
		if (color) {
			el.style.border = `2px solid ${color}`,
			el.style.backgroundColor = `${color}`
		}
		el.style.width= Math.round(bbox[2])+ 'px';
		el.style.height= Math.round(bbox[3]) + 'px';
		el.style.top= Math.round(bbox[1] -bbox[3]/2) + 'px';
		el.style.left= Math.round(bbox[0] - bbox[2]/2) + 'px';
		parent.append(el);
		return el;
	}

	const createArrow = function({className, tag = 'div', bbox, parent, rotationCoefficient, length}) {
		const el = document.createElement(tag);
		el.className = className;
		el.style.top= Math.round(bbox[1]) + 'px';
		el.style.left= Math.round(bbox[0]) + 'px';
		if (rotationCoefficient) {
			el.style.transform = `rotate(${rotationCoefficient}deg)`
		}
		el.style.height = length
		parent.append(el);
		return el;
	}

	const createCustomDashedLine = function({className, tag = 'div', bbox, parent, percentage}) {
		// bbox contains 3 elements: left, top and bottom of the dashed line
		const el = document.createElement(tag);
		el.className = className;
		el.style.width = 4 +'px';
		el.style.height= Math.abs(bbox[1] - bbox[2]) + 'px';
		el.style.top= bbox[1] + 'px';
		el.style.left = bbox[0] + 'px'
		el.style.backgroundImage = "url(`data:image/svg+xml,%3csvg width='100%25' height='100%25' xmlns='http://www.w3.org/2000/svg'%3e%3crect width='100%25' height='100%25' fill='none' stroke='black' stroke-width='10' stroke-dasharray='10%2c$10' stroke-dashoffset='0' stroke-linecap='round'/%3e%3c/svg%3e`)"
		parent.append(el);
		return el;
	}

	const createGroupBoxes = function({mean, covariance, color}) {
		const center = [mean[0][0] + mean[2][0]/2, mean[1][0] + mean[3][0]/2];
		const el = createElement({
			className: 'box',
			bbox: [center[0], center[1], mean[2][0], mean[3][0]],
			parent: img,
			color,
			lineStyle: 'solid',
		})
		const el2 = createElement({
			className: 'box',
			bbox: [
				center[0],
				center[1],
				mean[2][0] + 2*3*Math.sqrt(covariance[2][2]),
				mean[3][0] +2*3*Math.sqrt(covariance[3][3])
			],
			parent: img,
			color,
			lineStyle: 'dotted'
		});
		const el3 = createPoint({
			bbox: [center[0], center[1], 2, 2],
			parent: img,
			color
		});
		const correlationXY = covariance[0][1]/(Math.sqrt(covariance[0][0])*Math.sqrt(covariance[1][1]))
		const el4 = createElement({
			className: 'ellipse',
			bbox: [
				center[0],
				center[1],
				2*3*Math.sqrt(covariance[0][0]),
				2*3*Math.sqrt(covariance[1][1])
			],
			parent: img,
			rotationCoefficient: correlationXY,
			color,
			lineStyle: 'dotted'
		});
	}

	noisyObservations.forEach((box, index) => {
		promise = promise.then(function(b, index){
			console.log("Predicted", predicted)
			const {mean, covariance} = predicted;
			const center = [mean[0][0] + mean[2][0]/2, mean[1][0] + mean[3][0]/2];

			const predictedGroupBoxes = createGroupBoxes({mean, covariance, color: 'red'})


			return new Promise((resolve, reject) => {
				setTimeout(() => {
					resolve()
				}, delay);
			})
		}.bind(null, box, index))
		.then(function(b, index){
			const el = createElement({
				className: 'box',
				bbox: [
					b[0] +b[2]/2,
					b[1] +b[3]/2,
					b[2],
					b[3]
				],
				parent: img,
				color: 'white',
				lineStyle: 'solid'
			})

			return new Promise((resolve, reject) => {
				setTimeout(() => {
					resolve()
				}, delay);
			})
		}.bind(null, box, index))
		.then(function(b, index){
			previousCorrected = kf.correct({predicted, observation: b});
			console.log("box", b);
			console.log("Corrected", previousCorrected)
			const {mean, covariance} = previousCorrected

			const correctedGroupBoxes = createGroupBoxes({mean, covariance, color: 'blue'})
			const center = [mean[0][0] + mean[2][0]/2, mean[1][0] + mean[3][0]/2];

			const arrowRotation = -Math.atan(mean[4][0]/mean[5][0])*180/Math.PI -45;
			const arrowLength = Math.sqrt(mean[4][0]**2 + mean[5][0]**2);
			const el5 = createArrow({
				className: 'arrow',
				bbox: [
					center[0] -15,
					center[1] -9
				],
				parent: img,
				rotationCoefficient: arrowRotation,
				length: arrowLength
			})
			const correlationXW = covariance[0][2]/(Math.sqrt(covariance[0][0])*Math.sqrt(covariance[2][2]))
			const dashedLine = createCustomDashedLine({
				className: 'box',
				bbox: [
					center[0],
					center[0] - 3*Math.sqrt(covariance[1][1]),
					center[0] - mean[3][0]/2 - 3*Math.sqrt(covariance[3][3]),
				],
				parent: img,
				percentage: Math.abs(correlationXW) * 100
			})
			predicted = kf.predict({previousCorrected})
		return new Promise((resolve, reject) => {
			setTimeout(() => {
				resolve()
			}, delay);
		})
	}.bind(null, box, index))
	})



</script>

</html>
